---
title: "ã€å€‹äººãƒ¡ãƒ¢ã€‘é–‹ç™ºç’°å¢ƒæ§‹ç¯‰æ‰‹é †ãƒ¡ãƒ¢ - ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰"
emoji: "ğŸ¦”"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["Go", "Echo", "Gorm", "RestAPI"]
published: false
---

# æ¦‚è¦

- Docker/ã‚³ãƒ³ãƒ†ãƒŠç’°å¢ƒ
  - ãƒ›ãƒƒãƒˆãƒªãƒ­ãƒ¼ãƒ‰
  - ãƒ‡ãƒãƒƒã‚°
- Go
  - Echo
  - CleanArchitecture
  - GORM

å®Ÿè£…ã¯ãƒ­ã‚°ã‚¤ãƒ³ã¾ã§ã®ã‚‚ã®ã‚’è¨˜è¼‰ã™ã‚‹ã€‚

- v1.0
  - /tasks ã®ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®å®Ÿè£…ã¯ GitHub ã‚’å‚ç…§
- v2.0
  - /tasks ã®ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã¯ GitHub ã‚’å‚ç…§

# ç’°å¢ƒæ§‹ç¯‰æ‰‹é †ï¼ˆv1.0ï¼‰

## ãƒ™ãƒ¼ã‚¹ã®ä½œæˆ

- ã¾ãšã€ãƒ™ãƒ¼ã‚¹ã¨ãªã‚‹ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½œæˆã™ã‚‹ã€‚

```sh
mkdir hoge-app
```

- docker-compose ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆ

```sh
touch docker-compose.yml
```

- docker-compose.yml

```yml
version: "3.8"

services:
  app:
    build: ./trello-clone
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=development
    volumes:
      - ./trello-clone:/app
  db:
    container_name: trello-clone-db
    image: postgres:15.1-alpine
    ports:
      - 5434:5432
    environment:
      POSTGRES_USER: db-dev-user
      POSTGRES_PASSWORD: password
      POSTGRES_DB: dev-db
    volumes:
      - db-data:/var/lib/postgresql/data
    restart: always
  api:
    container_name: trello-clone-api
    build: ./trello-clone-api
    ports:
      - "8080:8080"
      - "2345:2345" #delvï¼ˆãƒ‡ãƒãƒƒã‚°ï¼‰ç”¨ã®ãƒãƒ¼ãƒˆ
    environment:
      GO_ENV: dev
      PORT: 8080
      POSTGRES_USER: db-dev-user
      POSTGRES_PW: password
      POSTGRES_DB: dev-db
      POSTGRES_PORT: 5432
      POSTGRES_HOST: db # Dockerã§apièµ·å‹•æ™‚
      #POSTGRES_HOST=localhost # ãƒ­ãƒ¼ã‚«ãƒ«èµ·å‹•æ™‚
      SECRET: devsecret
      API_DOMAIN: localhost
      FE_URL: http://app:3000 #ã‚³ãƒ³ãƒ†ãƒŠèµ·å‹•æ™‚
      FE_URL2: http://localhost:3000 #ãƒ­ãƒ¼ã‚«ãƒ«èµ·å‹•æ™‚
    volumes:
      - ./trello-clone-api:/app

volumes:
  db-data:
    driver: local
```

æ³¨æ„ï¼šå„ã‚µãƒ¼ãƒ“ã‚¹ãŒä»–ã®ãƒãƒ¼ãƒˆç•ªå·ã¨è¢«ã‚‰ãªã„ã‚ˆã†æ³¨æ„ã™ã‚‹

- API ã¨ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆç”¨ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½œæˆã™ã‚‹ã€‚

```sh
cd hoge-app
mkdir frontend backend
```

## API ã®å®Ÿè£…

- go ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä½œæˆ

```sh
cd backend
# hoge-app-rest-apiã¯ä»»æ„ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå
go mod init hoge-app-rest-api
```

- Dockerfile ã®æº–å‚™

```Dockerfile
FROM golang:1.21-alpine

WORKDIR /app
#COPY . /app
COPY go.mod /app
COPY startup.sh /app
COPY air.toml /app

RUN go mod download
RUN apk add --no-cache bash
# delvã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ï¼ˆãƒ‡ãƒãƒƒã‚°ï¼‰
RUN go install github.com/go-delve/delve/cmd/dlv@latest
#RUN go install github.com/go-delve/delve/cmd/dlv@v1.21.2
# airã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ï¼ˆãƒ›ãƒƒãƒˆãƒªãƒ­ãƒ¼ãƒ‰ï¼‰
RUN go install github.com/cosmtrek/air@latest
#RUN go install github.com/cosmtrek/air@v1.49.0

ENV PATH="/go/bin:${PATH}"

RUN chmod +x ./startup.sh

EXPOSE 8080

CMD ["/bin/bash", "./startup.sh"]
```

- startup.sh ã®ä½œæˆ

```sh
#!/bin/bash

# ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
go run migrate/migrate.go

# ãƒ›ãƒƒãƒˆãƒªãƒ­ãƒ¼ãƒ‰ã§ã®å®Ÿè¡Œ
# air

# ãƒ‡ãƒãƒƒã‚°ã§ã®å®Ÿè¡Œ
dlv debug ./main.go --headless --listen=:2345 --log --api-version=2
```

ãƒ‡ãƒãƒƒã‚°ã‹ãƒ›ãƒƒãƒˆãƒªãƒ­ãƒ¼ãƒ‰ã§ã®å®Ÿè¡Œã«åˆã‚ã›ã¦ä¸Šè¨˜ã‚’å¤‰æ›´ã™ã‚‹ã€‚
â€»ã“ã“ã¯èª²é¡Œï¼šãƒ›ãƒƒãƒˆãƒªãƒ­ãƒ¼ãƒ‰ã‹ã¤ãƒ‡ãƒãƒƒã‚°ãŒã§ãã‚Œã°æœ€é©

- .env ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”¨æ„
  ç’°å¢ƒå¤‰æ•°ã‚’æ ¼ç´ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”¨æ„

â€»ã“ã“ã¯ Docker ä½¿ã†ãªã‚‰ç’°å¢ƒå¤‰æ•°ã¯ docker-compose.yml ã§ã‚‚ã„ã„ã‹ã‚‚

```sh
touch .env
```

```env
PORT=8080
POSTGRES_USER=user
POSTGRES_PW=password
POSTGRES_DB=mydb
POSTGRES_PORT=5434
POSTGRES_HOST=localhost
SECRET={JWTãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç”Ÿæˆã™ã‚‹éš›ã«ä½¿ç”¨ã™ã‚‹ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆã‚­ãƒ¼}
GO_ENV=dev
API_DOMAIN=localhost
FE_URL=http://localhost:3000
```

å„ç’°å¢ƒå¤‰æ•°ã‚’å®šç¾©ã—ã¦ã„ãã€‚

- ãƒ›ãƒƒãƒˆãƒªãƒ­ãƒ¼ãƒ‰ãƒ©ã‚¤ãƒ–ãƒ©ãƒª air ã®è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆ

```sh
touch air.toml
```

```toml
# .air.toml
root = "."
tmp_dir = "tmp"

[build]
cmd = "go build -o ./tmp/main ."
delay = 1000 # ms
stop_signal = "SIGTERM"
exclude_dir = ["assets", "tmp", "vendor"]
include_ext = ["go", "tpl", "tmpl", "html"]
exclude_file = []
exclude_regex = []
exclude_unchanged = false
follow_symlink = false
full_bin = "/app/tmp/main"

[log]
time = true
level = "debug"

[misc]
clean_on_exit = true
```

- CleanArchitecture ã§å®Ÿè£…ã—ã¦ã„ããŸã‚ã®å„å±¤ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã€ãŠã‚ˆã³å¿…è¦ãªãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ç”¨æ„

```sh
mkdir db migrate router controller usecase repository model validator
```

CleanArchitecture ã®å„å±¤ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®å‘½åã¯ã”è‡ªç”±ã«

- ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆã‚’ç”¨æ„

```sh
touch main.go
```

```go
package main

import (
	// å„ç’°å¢ƒã«åˆã‚ã›ã¦å„å±¤ã‚’import
)

func main() {
	connectDB := db.NewDB()

	// user
	userValidation := validator.NewUserValidator()
	userRepository := repository.NewUserRepository(connectDB)
	userUsecase := usecase.NewUserUsecase(userRepository, userValidation)
	userController := controller.NewUserController(userUsecase)

	// router
	e := router.NewRouter(userController)
	e.Logger.Fatal(e.Start(":8080"))
}
```

- users ãƒ†ãƒ¼ãƒ–ãƒ«ã«é–¢ã™ã‚‹ model ã‚’ç”¨æ„

```sh
touch model/user.go
```

```go
package model

import "time"

type User struct {
	// GORMã®æ©Ÿèƒ½ã§ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ™‚ã«è‡ªå‹•ã§è¤‡æ•°å½¢ã«ã—ã¦ãã‚Œã‚‹ã€‚
	// â†’usersãƒ†ãƒ¼ãƒ–ãƒ«ã‚’ä½œæˆ
	ID        uint      `json:"id" gorm:"primaryKey"` //intã®primaryKeyã‚’æŒ‡å®šã™ã‚‹ã“ã¨ã§AuotIncrementã‚‚è¨­å®šã•ã‚Œã‚‹ã€‚ï¼ˆGORMï¼‰
	Email     string    `json:"email" gorm:"unique; not null;"`
	Password  string    `json:"password" gorm:"not null"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

type UserResponse struct {
	ID    uint   `json:"id"`
	Email string `json:"email"`
}
```

- ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”¨æ„ï¼ˆãƒ­ã‚°ã‚¤ãƒ³ã«é–¢ã™ã‚‹ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã¨ã‚µãƒ³ãƒ—ãƒ«ã®ã¿ç”¨æ„ï¼‰

```sh
touch router/router.go
```

```go
package router

import (
	// å„ç’°å¢ƒã«åˆã‚ã›ã¦controllerã‚’import
	"net/http"
	"os"

	echojwt "github.com/labstack/echo-jwt/v4"
	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"
)

func NewRouter(uc controller.IUserController, fc controller.IFavoriteController) *echo.Echo {
	e := echo.New()

	e.Use(middleware.CORSWithConfig(middleware.CORSConfig{
		// DefaultCORSConfig = CORSConfig{
		// 	Skipper:      DefaultSkipper,
		// 	AllowOrigins: []string{"*"},
		// 	AllowMethods: []string{http.MethodGet, http.MethodHead, http.MethodPut, http.MethodPatch, http.MethodPost, http.MethodDelete},
		// }
		AllowOrigins: []string{"http://localhost:3000", os.Getenv("FE_URL")},
		AllowHeaders: []string{echo.HeaderOrigin, echo.HeaderContentType, echo.HeaderAccept,
			echo.HeaderAccessControlAllowOrigin, echo.HeaderXCSRFToken},
		AllowCredentials: true,
	}))

	e.Use(middleware.CSRFWithConfig(middleware.CSRFConfig{
		// DefaultCSRFConfig = CSRFConfig{
		// 	Skipper:      DefaultSkipper,
		// 	TokenLength:  32,
		// 	TokenLookup:  "header:" + echo.HeaderXCSRFToken,
		// 	ContextKey:   "csrf",
		// 	CookieName:   "_csrf",
		// 	CookieMaxAge: 86400,
		// }
		CookiePath:     "/",
		CookieDomain:   os.Getenv("API_DOMAIN"),
		CookieSecure:   true,
		CookieHTTPOnly: true,
		CookieSameSite: http.SameSiteNoneMode,
		// CookieSameSite: http.SameSiteDefaultMode, //PostManç¢ºèªç”¨ã€‚ï¼ˆSameSiteNoneModeã ã¨SecureãŒè‡ªå‹•ã§trueã«ãªã‚‹ãŸã‚ï¼‰
	}))

	e.POST("/signup", uc.SignUp)
	e.POST("/login", uc.Login)
	e.POST("/logout", uc.Logout)
	e.GET("/csrf", uc.GetCsrf)

	// â†“â†“ä»¥é™ã¯å‚è€ƒä¾‹â†“â†“
	h := e.Group("/hoge")
	h.Use(echojwt.WithConfig(echojwt.Config{
		// **************************
		// /hoge/*ã«å¯¾ã—ã¦jwtã‚’ä½¿ç”¨ã™ã‚‹ä¾‹
		// **************************
		// Optional. Default value "header:Authorization".
		TokenLookup: "cookie:token",
		SigningKey:  []byte(os.Getenv("SECRET")),
	}))
	h.GET("", fc.GetHoge)
	// â†‘â†‘ä»¥é™ã¯å‚è€ƒä¾‹â†‘â†‘

	e.Use(middleware.Logger())
	return e
}
```

- controller

ãƒ­ã‚°ã‚¤ãƒ³æ©Ÿèƒ½ã«é–¢ã™ã‚‹ controller ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆ

```sh
touch controller/user_controller.go
```

```go
package controller

import (
	//å„ç’°å¢ƒã«åˆã‚ã›ã¦modelã¨usecaseã‚’import
	"net/http"
	"os"
	"time"

	"github.com/labstack/echo/v4"
)

// interface
type IUserController interface {
	SignUp(c echo.Context) error
	Login(c echo.Context) error
	Logout(c echo.Context) error
	GetCsrf(c echo.Context) error
}

// interfaceã‚’å®Ÿè£…ã™ã‚‹struct
type userController struct {
	uu usecase.IUserUsecase
}

// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
func NewUserController(uu usecase.IUserUsecase) IUserController {
	return &userController{uu: uu}
}

// ãƒ¡ã‚½ãƒƒãƒ‰å®šç¾©
func (uc *userController) SignUp(c echo.Context) error {
	user := model.User{}
	if err := c.Bind(&user); err != nil {
		return c.JSON(http.StatusBadRequest, err.Error())
	}
	resUser, err := uc.uu.SignUp(user)
	if err != nil {
		return c.JSON(http.StatusInternalServerError, err.Error())
	}
	return c.JSON(http.StatusCreated, resUser)
}

func (uc *userController) Login(c echo.Context) error {
	user := model.User{}
	if err := c.Bind(&user); err != nil {
		return c.JSON(http.StatusBadRequest, err.Error())
	}
	token, err := uc.uu.Login(user)
	if err != nil {
		return c.JSON(http.StatusBadRequest, err.Error())
	}
	cookie := http.Cookie{
		Name:     "token",
		Value:    token,
		Path:     "/",
		Domain:   os.Getenv("API_DOMAIN"),
		Expires:  time.Now().Add(24 * time.Hour),
		Secure:   true, //Postmanã§ãƒ†ã‚¹ãƒˆã™ã‚‹ã¨ãã¯ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆ
		HttpOnly: true,
		SameSite: http.SameSiteNoneMode, // ãƒ•ãƒ­ãƒ³ãƒˆSPAã®ãŸã‚ã€None
	}
	c.SetCookie(&cookie)
	return c.NoContent(http.StatusOK)
}

func (uc *userController) Logout(c echo.Context) error {
	cookie := http.Cookie{
		Name:    "token",
		Value:   "",
		Path:    "/",
		Domain:  os.Getenv("API_DOMAIN"),
		Expires: time.Now(),
		// Secure:   true, //Postmanã§ãƒ†ã‚¹ãƒˆã™ã‚‹ã¨ãã¯ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆ
		HttpOnly: true,
		SameSite: http.SameSiteNoneMode, // ãƒ•ãƒ­ãƒ³ãƒˆSPAã®ãŸã‚ã€None
	}
	c.SetCookie(&cookie)
	return c.NoContent(http.StatusOK)
}

func (uc *userController) GetCsrf(c echo.Context) error {
	token := c.Get("csrf").(string)
	return c.JSON(http.StatusOK, echo.Map{
		"csrf_token": token,
	})
}
```

- usecase

ãƒ­ã‚°ã‚¤ãƒ³æ©Ÿèƒ½ã«é–¢ã™ã‚‹ usecase ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆ

```sh
touch usecase/user_usecase.go
```

```go
package usecase

import (
	// å„ç’°å¢ƒã«åˆã‚ã›ã¦modelã€repositoryã€validatorã‚’importã™ã‚‹

	"os"
	"time"
	"trello-colen-api/model"

	"github.com/golang-jwt/jwt/v5"
	"golang.org/x/crypto/bcrypt"
)

// ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
type IUserUsecase interface {
	SignUp(user model.User) (model.UserResponse, error)
	Login(user model.User) (string, error)
}

// ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å®Ÿè£…ã™ã‚‹struct
type userUsecase struct {
	ur repository.IUserRepository
	uv validator.IUserValidator
}

// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
func NewUserUsecase(ur repository.IUserRepository, uv validator.IUserValidator) IUserUsecase {
	return &userUsecase{ur: ur, uv: uv}
}

//å‡¦ç†éƒ¨

// SignUpï¼šãƒ¦ãƒ¼ã‚¶ãƒ¼ç™»éŒ²
func (uu *userUsecase) SignUp(user model.User) (model.UserResponse, error) {
	if err := uu.uv.UserValidate(user); err != nil {
		return model.UserResponse{}, err
	}
	hashPass, err := bcrypt.GenerateFromPassword([]byte(user.Password), 10)
	if err != nil {
		return model.UserResponse{}, err
	}
	newUser := model.User{
		Email:    user.Email,
		Password: string(hashPass),
	}
	if err := uu.ur.CreateUser(&newUser); err != nil {
		return model.UserResponse{}, err
	}
	userRes := model.UserResponse{
		ID:    newUser.ID,
		Email: newUser.Email,
	}
	return userRes, nil
}

func (uu *userUsecase) Login(user model.User) (string, error) {
	storedUser := model.User{}
	if err := uu.ur.GetUserByEmail(&storedUser, user.Email); err != nil {
		return "", err
	}
	if err := bcrypt.CompareHashAndPassword([]byte(storedUser.Password), []byte(user.Password)); err != nil {
		return "", err
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, &jwt.MapClaims{
		"user_id": storedUser.ID,
		"exp":     time.Now().Add(time.Hour * 12).Unix(),
	})
	tokenString, err := token.SignedString([]byte(os.Getenv("SECRET")))
	if err != nil {
		return "", err
	}
	return tokenString, nil
}
```

- repository

ãƒ­ã‚°ã‚¤ãƒ³æ©Ÿèƒ½ã«é–¢ã™ã‚‹ repostory ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆ

```sh
touch repository/user_repository.go
```

```go
package repository

import (
	// å„ç’°å¢ƒã«åˆã‚ã›ã¦modelã‚’importã™ã‚‹

	"gorm.io/gorm"
)

// ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
type IUserRepository interface {
	GetUserByEmail(user *model.User, email string) error
	CreateUser(user *model.User) error
}

// ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å®Ÿè£…ã™ã‚‹æ§‹é€ ä½“
type userRepository struct {
	db *gorm.DB
}

// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
func NewUserRepository(db *gorm.DB) IUserRepository {
	return &userRepository{db: db}
}

// å®Ÿè£…éƒ¨
func (ur *userRepository) GetUserByEmail(user *model.User, email string) error {
	if err := ur.db.Where("email = ?", email).First(user).Error; err != nil {
		return err
	}
	return nil
}

func (ur *userRepository) CreateUser(user *model.User) error {
	if err := ur.db.Create(user).Error; err != nil {
		return err
	}
	return nil
}
```

- validator

ãƒ­ã‚°ã‚¤ãƒ³æ©Ÿèƒ½ã«é–¢ã™ã‚‹ validator ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆ

```sh
touch validator/user_validator.go
```

```go
package validator

import (
	// å„ç’°å¢ƒã«åˆã‚ã›ã¦modelã‚’importã™ã‚‹

	validation "github.com/go-ozzo/ozzo-validation/v4"
	"github.com/go-ozzo/ozzo-validation/v4/is"
)

type IUserValidator interface {
	UserValidate(user model.User) error
}

type userValidator struct{}

func NewUserValidator() IUserValidator {
	return &userValidator{}
}

func (uv *userValidator) UserValidate(user model.User) error {
	return validation.ValidateStruct(&user,
		validation.Field(
			&user.Email,
			validation.Required.Error("email is required"),
			validation.RuneLength(1, 30).Error("limited max 30 char"),
			is.Email.Error("is not valid email format"),
		),
		validation.Field(
			&user.Password,
			validation.Required.Error("password is required"),
			validation.RuneLength(6, 30).Error("limited min 6 max 30 char"),
		),
	)
}
```

- db/db.go ã‚’ä½œæˆã—ã€ç·¨é›†

```sh
touch db/db.go
```

db.go ã« db æ¥ç¶šã¨ã‚¯ãƒ­ãƒ¼ã‚ºã™ã‚‹ãŸã‚ã®é–¢æ•°ã‚’ä½œæˆ

```go
package db

import (
	"fmt"
	"log"
	"os"

	// "github.com/joho/godotenv"
	"gorm.io/driver/postgres"
	"gorm.io/gorm"
)

func NewDB() *gorm.DB {
	// Dockerã®ç’°å¢ƒå¤‰æ•°ã§è¨­å®šã—ã¦ã„ã‚‹ãŸã‚ä»¥ä¸‹ã¯ä¸è¦ã«ãªã‚Šãã†
	// if os.Getenv("GO_ENV") == "dev" {
	// 	err := godotenv.Load()
	// 	if err != nil {
	// 		log.Fatalln(err)
	// 	}
	// }
	url := fmt.Sprintf("postgres://%s:%s@%s:%s/%s", os.Getenv("POSTGRES_USER"),
		os.Getenv("POSTGRES_PW"), os.Getenv("POSTGRES_HOST"), os.Getenv("POSTGRES_PORT"), os.Getenv("POSTGRES_DB"))
	db, err := gorm.Open(postgres.Open(url), &gorm.Config{})
	if err != nil {
		log.Fatalln(err)
	}
	fmt.Println("db connected!")
	return db
}

func CloseDB(db *gorm.DB) {
	sqlDB, _ := db.DB()
	if err := sqlDB.Close(); err != nil {
		log.Fatalln(err)
	}
}
```

go mod tidy ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã—ã¦ã€gormã€godotenvã€postgresql ã®ãƒ‰ãƒ©ã‚¤ãƒãƒ¼ã®ä¾å­˜é–¢ä¿‚ã‚’è§£æ±ºã—ã¦ãŠãã€‚

- migrate/migrate.go ã‚’ä½œæˆã—ã€ç·¨é›†

```sh
touch migrate/migrate.go
```

ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã®é–¢æ•°ä½œæˆ

```go
package main

import (
	"fmt"
	// å„ç’°å¢ƒã«åˆã‚ã›ã¦ã€dbã¨modelã‚’import
)

func main() {
	dbConn := db.NewDB()
	defer fmt.Println("Successfully Migrated")
	defer db.CloseDB(dbConn)
	// ä¾‹ï¼šuserã¨taskãƒ†ãƒ¼ãƒ–ãƒ«ã‚’ä½œæˆã—ãŸã„å ´åˆ
	dbConn.AutoMigrate(&model.User{}) //ä½œæˆã—ãŸã„ãƒ¢ãƒ‡ãƒ«ã®structã‚’0å€¤ã§å¼•æ•°ã«æ¸¡ã™
}
```

- ã‚³ãƒ³ãƒ†ãƒŠç’°å¢ƒã§ãƒ‡ãƒãƒƒã‚°å®Ÿè¡Œã§ãã‚‹ã‚ˆã†ã«ã—ã¦ãŠãã€‚

```sh
touch .vscode/launch.json
```

```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Docker: Attach to Go",
      "type": "go",
      "request": "attach",
      "mode": "remote",
      "remotePath": "/app",
      // "program": "${workspaceFolder}/main.go",
      "port": 2345,
      "host": "127.0.0.1",
      "showLog": true,
      "debugAdapter": "legacy" //2024/04æ™‚ç‚¹ï¼šç‰¹å®šã®vscodeã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã ã¨ã“ã®è¨­å®šã«ã—ã¦ãŠã‹ãªã„ã¨ãƒ–ãƒ¬ãƒ¼ã‚¯ãƒã‚¤ãƒ³ãƒˆãŒç„¡åŠ¹åŒ–ã•ã‚Œã‚‹ã€‚https://github.com/golang/vscode-go/issues/3175
    }
  ]
}
```

docker-compose ã§ã‚³ãƒ³ãƒ†ãƒŠèµ·å‹•å¾Œã€ãƒ‡ãƒãƒƒã‚°ï¼ˆDocker: Attach to Goï¼‰ã‚’èµ·å‹•ã™ã‚‹ã¨ã‚³ãƒ³ãƒ†ãƒŠç’°å¢ƒã®ã‚³ãƒ¼ãƒ‰ã‚’ãƒ‡ãƒãƒƒã‚°ã§ãã‚‹ã€‚
æ³¨æ„ç‚¹ã¨ã—ã¦ã¯ãƒ‡ãƒãƒƒã‚°å®Ÿè¡Œã—ãŸå ´åˆã¯ã€ãƒ‡ãƒãƒƒã‚¬ãƒ¼ã‚’èµ·å‹•ã—ãªã„ã¨ãƒ—ãƒ­ã‚°ãƒ©ãƒ è‡ªä½“ãŒèµ·å‹•ã—ãªã„ç‚¹

- ãƒ›ãƒƒãƒˆãƒªãƒ­ãƒ¼ãƒ‰
  startup.sh å†…ã® air ã§ã®èµ·å‹•ã‚³ãƒãƒ³ãƒ‰ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚’å¤–ã—ã€ãƒ‡ãƒãƒƒã‚°å®Ÿè¡Œã®ã‚³ãƒãƒ³ãƒ‰ã‚’ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã™ã‚‹ã€‚

```sh
# ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
go run migrate/migrate.go

# ãƒ›ãƒƒãƒˆãƒªãƒ­ãƒ¼ãƒ‰å®Ÿè¡Œ
air
# ãƒ‡ãƒãƒƒã‚°å®Ÿè¡Œ
# dlv debug ./main.go --headless --listen=:2345 --log --api-version=2
```

### v1.0 ã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰

ã“ã“ã¾ã§ã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã¯ä»¥ä¸‹ã‚’å‚ç…§

```sh
git clone https://github.com/Yuji-Momotani/sample-go-rest-api-echo.git -b v1.1
```

ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã§ã¯ã€èªè¨¼æ©Ÿèƒ½ä»¥å¤–ã«`/tasks`ã®ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®å‡¦ç†ã‚‚å®Ÿè£…

# ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã®è¿½åŠ (v2.0)

## DB ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ç¢ºç«‹ã®ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰

ã¾ãšã€db/db.go ã§ DB ã¸ã®ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚’ç¢ºç«‹ã—ã¦ã„ã‚‹å‡¦ç†ã®ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã‚’è¨˜è¿°ã™ã‚‹ãŸã‚ã«ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’å¤‰æ›´ã—ã¾ã™ã€‚  
ã‚‚ã—ã€Openã€Cloese æ™‚ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸã‚‰ã€ã™ãã«`log.Fatal`ã§ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’çµ‚äº†ã•ã›ã¦ã„ãŸã¨ã“ã‚ã‚’ã€ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã™ã‚ˆã†ã«å¤‰æ›´ã—ã¾ã™ã€‚

```go
func NewDB() (*gorm.DB, error) {
	url := fmt.Sprintf("postgres://%s:%s@%s:%s/%s", os.Getenv("POSTGRES_USER"),
		os.Getenv("POSTGRES_PW"), os.Getenv("POSTGRES_HOST"), os.Getenv("POSTGRES_PORT"), os.Getenv("POSTGRES_DB"))
	db, err := gorm.Open(postgres.Open(url), &gorm.Config{})
	if err != nil {
		return nil, err
	}
	fmt.Println("db connected!")
	return db, nil
}

func CloseDB(db *gorm.DB) error {
	sqlDB, _ := db.DB()
	if err := sqlDB.Close(); err != nil {
		return err
	}
	return nil
}
```

ã“ã¡ã‚‰ã«å¯¾ã—ã¦ã€ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã‚’è¨˜è¿°ã—ã¾ã™ã€‚

`db/db_test.go`

```go
func setEnv() {
	os.Setenv("POSTGRES_USER", "user")
	os.Setenv("POSTGRES_PW", "password")
	os.Setenv("POSTGRES_HOST", "localhost") //ãƒ­ãƒ¼ã‚«ãƒ«ã‹ã‚‰å®Ÿè¡Œã™ã‚‹ã¨ãã¯ã€127.0.0.1
	os.Setenv("POSTGRES_PORT", "5434")
	os.Setenv("POSTGRES_DB", "mydb")
}

func clearEnv() {
	os.Unsetenv("POSTGRES_USER")
	os.Unsetenv("POSTGRES_PW")
	os.Unsetenv("POSTGRES_HOST")
	os.Unsetenv("POSTGRES_PORT")
	os.Unsetenv("POSTGRES_DB")
}

func TestNewDB(t *testing.T) {
	tests := []struct {
		name        string
		envSetup    func()
		expectError bool
	}{
		{
			name: "Success",
			envSetup: func() {
				setEnv()
			},
			expectError: false,
		},
		{
			name: "missing enviroment variables",
			envSetup: func() {
				clearEnv()
			},
			expectError: true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.envSetup()
			defer clearEnv()
			db, err := NewDB()
			if tt.expectError {
				// å¤±æ•—ã™ã‚‹ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹
				assert.Error(t, err)
			} else {
				// æˆåŠŸã™ã‚‹ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹
				assert.NotNil(t, db)
				sqlDB, err := db.DB()
				assert.NoError(t, err)
				assert.NoError(t, sqlDB.Ping())
			}
		})
	}
}

func TestCloseDB(t *testing.T) {
	type args struct {
		db *gorm.DB
	}
	tests := []struct {
		name string
		args args
	}{
		{
			name: "Success",
			args: args{
				db: func() *gorm.DB {
					setEnv()
					defer clearEnv()
					db, _ := NewDB()
					return db
				}(),
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := CloseDB(tt.args.db)
			assert.NoError(t, err)

			sqlDB, _ := tt.args.db.DB()
			assert.Error(t, sqlDB.Ping())
		})
	}
}
```

ã“ã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã§ã¯ã€Docker ã® Postgre ã‚³ãƒ³ãƒ†ãƒŠã‚’èµ·å‹•ã—ã¦ãŠãå¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

### ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ä½œæˆãƒ„ãƒ¼ãƒ«

vscode ã§`cmd + shift + p`ã‹ã‚‰ã‚³ãƒãƒ³ãƒ‰ãƒ‘ã‚±ãƒƒãƒˆã‚’é–‹ã„ã¦ã€`Go: Generate Unit Tests For Function` ã‚‚ã—ãã¯ `Go: Generate Unit Tests For File`ã‚’é¸æŠã™ã‚‹ã“ã¨ã§è‡ªå‹•ç”Ÿæˆã—ã¦ãã‚Œã‚‹ã€‚

åŒæ§˜ã«ä»–ã®ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã‚‚è¨˜è¿°ã—ã¦ã„ãã€‚

# GitHub Actions ã«ã‚ˆã‚‹ CI ç’°å¢ƒã®æ§‹ç¯‰(v3.0)

./github/workflows é…ä¸‹ã« yaml ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç½®ãã“ã¨ã§ GitHubActions ä¸Šã§è‡ªå‹•ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œã—ã¦ãã‚Œã‚‹ã€‚

```yml
name: unit-test

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  build:
    runs-on: ubuntu-22.04

    services:
      postgres:
        image: postgres:15.1-alpine
        ports:
          - 15434:5432
        env:
          POSTGRES_USER: testuser
          POSTGRES_PASSWORD: testpassword
          POSTGRES_DB: testmydb
        # options: >-
        #   --health-cmd="pg_isready"
        #   --health-interval=10s
        #   --health-timeout=5s
        #   --health-retries=5

    env:
      POSTGRES_USER: testuser
      POSTGRES_PASSWORD: testpassword
      POSTGRES_DB: testmydb
      POSTGRES_HOST: 127.0.0.1
      POSTGRES_PORT: 5432
      SECRET: devsecret
      API_DOMAIN: localhost

    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Set up Go
        uses: actions/setup-go@v3
        with:
          go-version: 1.21

      - name: Install dependencies
        run: go mod download

      - name: Run tests
        run: |
          go test -v ./...
```

ãƒ†ã‚¹ãƒˆãŒé€šã£ãŸã‚‰ OKã€‚

ãƒ†ã‚¹ãƒˆå®Ÿè¡Œçµæœã®ãƒãƒƒãƒã‚’ README.md ã«è²¼ã‚Šä»˜ã‘ã‚‹ã€‚ï¼ˆä»¥ä¸‹ã‹ã‚‰ãƒ‘ã‚¹ã‚’å–å¾—ã™ã‚‹ï¼‰

![alt text](/images/480d935f0edfe9/image1.png)
