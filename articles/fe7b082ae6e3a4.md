---
title: "Goè¨€èªã‚’åŸºç¤ã‹ã‚‰å¾¹åº•çš„ã«å©ãè¾¼ã‚€ã€œ#4-4 ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã€œ"
emoji: "ğŸ—‚"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["Go"]
published: false
---

# æ¦‚è¦

[ã“ã®è¨˜äº‹]()ã®ç¶šãã§ã™ï¼  
Go ã‚’ç”¨ã„ãŸã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã«ã¤ã„ã¦ã§ã™ï¼

# ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã«ã¤ã„ã¦ã¯ã€ä»¥å‰ã€[ã“ã¡ã‚‰ã®è¨˜äº‹]()ã§ãŒã£ã¤ã‚Šã¾ã¨ã‚ã¦ã„ã¾ã—ãŸã®ã§ã€ä»Šå›ã¯å¾©ç¿’ã‚‚å…¼ã­ã¦ç°¡å˜ã«ã¾ã¨ã‚ã‚ˆã†ã¨æ€ã„ã¾ã™ï¼  
æ¦‚å¿µçš„ãªã¨ã“ã‚ã¯é£›ã°ã—ã¦ã©ã†ã‚†ã†å®Ÿè£…ã«ãªã‚‹ã‹ã‚’ã¾ã¨ã‚ã¦ã„ãã¾ã™ã®ã§ã€è©³ç´°ã¯ä¸Šè¨˜ã®è¨˜äº‹ã‚’å‚è€ƒã«ã—ã¦ãã ã•ã„ã€‚  
ä»Šå›ã®æœ¬é¡Œã¯ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã§ã®ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã‚’ã©ã†ã™ã‚‹ã‹ã¨ã„ã†ã¨ã“ã‚ã§ã™ï¼

![clean_architecture](/images/fe7b082ae6e3a4/clean_architecture.png)
ä¸Šå›³ã®å„å±¤ã®å‘¼ã³æ–¹ã¯ãã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«ã‚ˆã£ã¦ã€ã¾ã¡ã¾ã¡ã«ãªã‚Šã¾ã™ãŒã€ä»Šå›ã¯

- controller å±¤ï¼šcontroller
- usecase å±¤ï¼ˆãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯å±¤ï¼‰ï¼šusecase
- Gateway å±¤ï¼ˆDB ã‚„ã‚Šå–ã‚Šã‚’è¡Œã†å±¤ï¼‰ï¼šrepository
- entity å±¤ï¼šmodel

ã¨ã—ã¦è¨˜è¼‰ã—ã¾ã™ï¼ä»Šå›ã¯ç°¡å˜ã«å®Ÿè£…ã—ãŸãŸã‚ã€ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã¯ main.go å†…ã§å®Ÿè£…ã—ã¾ã™ã€‚

## ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã§ã®å®Ÿè£…

ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã‚’å«ã‚ã€è¨­è¨ˆã§é‡è¦ãªã®ã¯ã€Œå¤‰æ›´å®¹æ˜“æ€§ã€ã€ã€Œæ‹¡å¼µæ€§ã€ã ã¨æ€ã£ã¦ã„ã¾ã™ã€‚  
ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã§ã¯ã€Œä¾å­˜é–¢ä¿‚é€†è»¢ã®åŸå‰‡ã€ã¨ã‹ã€ã€Œä¾å­˜æ€§ã®æ³¨å…¥ã€ã¨ã‹é›£ã—ã„è¨€è‘‰ãŒä¸¦ã³ã¾ã™ãŒã€è¦ã¯

- å„å±¤æ¯ã«é–¢å¿ƒã”ã¨ã‚’é©åˆ‡ã«åˆ†é›¢ã—ã€å„å±¤ã®ä¾å­˜å…ˆã‚’æŠ½è±¡å‹ï¼ˆinterfaceï¼‰ã«å‘ã‘ã‚‹ã“ã¨ã§ã€ä¾å­˜å…ˆï¼ˆå††ã®å†…å´ï¼‰ã®å…·ä½“çš„ãªå®Ÿè£…ãŒå¤‰æ›´ã«ãªã£ãŸã¨ã—ã¦ã‚‚å¤–å´ã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã«å½±éŸ¿ã‚’åŠã°ã•ãªã„ã€‚ï¼ˆãŸã ã—ã€Usecaseâ†’Eintities ã®ä¾å­˜é–¢ä¿‚ã¯ Interface ã§ã¯ãªã„ã®ã§ã€Entities ã®æ§‹é€ ä½“ã«å¤‰æ›´ãŒã‚ã‚‹ã¨ã€å¤–å´ã®å±¤ã®è©²å½“ç®‡æ‰€ã¯ä¿®æ­£ãŒå¿…è¦ï¼‰
- ã¾ãŸã€ä¾å­˜å…ˆã‚’å¿…ãšå††ã®å†…å´ã«å‘ã‘ã¦ã‚„ã‚‹ã“ã¨ã§ã€å††ã®å†…å´ã¯ã€å¤–å´ã®å¤‰æ›´ï¼ˆã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã®å¤‰æ›´ã€ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®å¤‰æ›´ï¼‰ã®å½±éŸ¿ã‚’å—ã‘ãªã„ã€‚

ã‹ãªã¨æ€ã„ã¾ã™ã€‚ã¾ãŸã€ãã®ä¸­ã§ã€repository ã¨ usecase ã¯ä¾å­˜é–¢ä¿‚ãŒå‡¦ç†ã®æµã‚Œã¨é€†å‘ãã«ãªã‚‹ã®ã§ã€é€†è»¢ã•ã›ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚ã“ã‚Œã‚’ã€Œä¾å­˜é–¢ä¿‚é€†è»¢ã®åŸå‰‡ã€ã¨è¨€ã£ã¦ã„ã‚‹ãŒã€ã‚„ã£ã¦ã‚‹ã“ã¨ã¯ä¾å­˜å…ˆã‚’æŠ½è±¡å‹ï¼ˆinterfaceï¼‰ã«å‘ã‘ã¦ã„ã‚‹ã ã‘ã€‚

- ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ 

```
.
â”œâ”€â”€ controller
â”‚   â””â”€â”€ task_controller.go
â”œâ”€â”€ model
â”‚   â””â”€â”€ task.go
â”œâ”€â”€ repository
â”‚   â””â”€â”€ task_repository.go
â”œâ”€â”€ usecase
â”‚   â””â”€â”€ task_usecase.go
â”œâ”€â”€ go.mod
â”œâ”€â”€ go.sum
â””â”€â”€ main.go
```

- main.go

```go
package main

import (
	"base/controller"
	"base/repository"
	"base/usecase"
	"database/sql"
	"fmt"
	"log"

	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"
)

func initDB() (*sql.DB, error) {
	db, err := sql.Open("sqlite3", "./test.db")
	return db, err
}

func main() {
	db, err := initDB()
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println(db)

	e := echo.New()
	e.Use(middleware.Logger())
	e.Use(middleware.Recover())

	taskRepository := repository.NewTaskRepository(db)
	taskUsecase := usecase.NewTaskUsecase(taskRepository)
	taskController := controller.NewTaskController(taskUsecase)
	e.GET("/tasks/:id", taskController.Get)
	e.POST("/tasks", taskController.Create)

	e.Start(":8080")
}
```

- model

```go
package model

import "errors"

type Task struct {
	ID    int    `json:"id"`
	Title string `json:"title"`
}

func (t *Task) Validate() error {
	if t.Title == "" {
		return errors.New("title is required")
	}
	return nil
}
```

- controller

```go
package controller

import (
	"base/model"
	"base/usecase"
	"fmt"
	"net/http"
	"strconv"

	"github.com/labstack/echo/v4"
)

type ITaskController interface {
	Get(c echo.Context) error
	Create(c echo.Context) error
}

type taskController struct {
	tu usecase.ITaskUsecase
}

func NewTaskController(tu usecase.ITaskUsecase) ITaskController {
	return &taskController{tu: tu}
}

func (tc *taskController) Get(c echo.Context) error {
	id, err := strconv.Atoi(c.Param("id"))
	if err != nil {
		errMsg := fmt.Errorf("parse error: %v", err.Error())
		return c.JSON(http.StatusBadRequest, errMsg.Error())
	}
	task, err := tc.tu.GetTask(id)
	if err != nil {
		return c.JSON(http.StatusInternalServerError, err)
	}
	return c.JSON(http.StatusOK, task)
}

func (tc *taskController) Create(c echo.Context) error {
	var task model.Task
	if err := c.Bind(&task); err != nil {
		return c.JSON(http.StatusBadRequest, err)
	}

	createdId, err := tc.tu.CreateTask(task.Title)
	if err != nil {
		return c.JSON(http.StatusInternalServerError, err)
	}
	return c.JSON(http.StatusOK, createdId)
}
```

- usecase

```go
package usecase

import (
	"base/model"
	"base/repository"
)

type ITaskUsecase interface {
	CreateTask(title string) (int, error)
	GetTask(id int) (*model.Task, error)
}

type taskUsecase struct {
	r repository.ITaskRepository
}

func NewTaskUsecase(r repository.ITaskRepository) ITaskUsecase {
	return &taskUsecase{r: r}
}

func (u *taskUsecase) CreateTask(title string) (int, error) {
	task := model.Task{Title: title}
	err := task.Validate()
	if err != nil {
		return 0, err
	}

	id, err := u.r.Create(&task)
	if err != nil {
		return 0, err
	}
	return id, nil
}

func (u *taskUsecase) GetTask(id int) (*model.Task, error) {
	t, err := u.r.Read(id)
	if err != nil {
		return nil, err
	}

	return t, nil
}
```

- repository

```go
package repository

import (
	"base/model"
	"database/sql"
)

type ITaskRepository interface {
	Create(task *model.Task) (int, error)
	Read(id int) (*model.Task, error)
}

type taskRepository struct {
	db *sql.DB
}

func NewTaskRepository(db *sql.DB) ITaskRepository {
	return &taskRepository{db: db}
}

func (r *taskRepository) Create(task *model.Task) (int, error) {
	stmt := `INSERT INTO tasks (title) VALUES (?) RETURNING id`
	err := r.db.QueryRow(stmt, task.Title).Scan(&task.ID)
	return task.ID, err
}

func (r *taskRepository) Read(id int) (*model.Task, error) {
	stmt := `SELECT id, title FROM tasks WHERE id = ?`
	task := model.Task{}
	err := r.db.QueryRow(stmt, id).Scan(&task.ID, &task.Title)
	return &task, err
}
```

## ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®ãƒ†ã‚¹ãƒˆ

ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã§ã¯å„å±¤ãŒä¾å­˜å…ˆã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å†…éƒ¨ã§ä½¿ç”¨ã™ã‚‹ãŸã‚ã€ãã‚Œã‚‰ã®ãƒ¢ãƒƒã‚¯ãŒå¿…è¦ã¨ãªã‚‹ã€‚
ä¾‹ãˆã°ã€usecase å±¤ã§è¨€ã†ã¨ã€ãƒªãƒã‚¸ãƒˆãƒªã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã™ã‚‹ãŸã‚ã€ãã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®ãƒ¢ãƒƒã‚¯ã‚’ç”¨æ„ã™ã‚‹ã€‚  
ä»Šå›ã¯ã€`"github.com/stretchr/testify/mock"`ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ç”¨ã—ã¦å®Ÿè£…

```go
// ITaskRepositoryã®ãƒ¢ãƒƒã‚¯
type ITaskRepositoryMock struct {
	mock.Mock
}

// taskRepositoryã®Createãƒ¡ã‚½ãƒƒãƒ‰ã®ãƒ¢ãƒƒã‚¯
func (m *ITaskRepositoryMock) Create(task *model.Task) (int, error) {
	args := m.Called(task)
	return args.Int(0), args.Error(1)
}

// taskRepositoryã®Readãƒ¡ã‚½ãƒƒãƒ‰ã®ãƒ¢ãƒƒã‚¯
func (m *ITaskRepositoryMock) Read(id int) (*model.Task, error) {
	args := m.Called(id)
	return args.Get(0).(*model.Task), args.Error(1)
}
```

ä¸Šè¨˜ã®ãƒ¢ãƒƒã‚¯ã‚’åˆ©ç”¨ã—ã€usecase ã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã‚’å®Ÿè£…ã—ãŸä¾‹ãŒä»¥ä¸‹

```go
// CreateTaskã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹
func TestTaskUsecase_CreateTask(t *testing.T) {
	mockRepo := new(ITaskRepositoryMock)
	taskUsecase := usecase.NewTaskUsecase(mockRepo)

	task := model.Task{Title: "test"}

	// ãƒ¢ãƒƒã‚¯ã®æˆ»ã‚Šå€¤ã‚’è¨­å®š
	mockRepo.On("Create", &task).Return(1, nil)

	id, err := taskUsecase.CreateTask(task.Title)
	assert.NoError(t, err)
	assert.Equal(t, 1, id)
}

// GetTaskã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹
func TestTaskUsecase_GetTask(t *testing.T) {
	mockRepo := new(ITaskRepositoryMock)
	taskUsecase := usecase.NewTaskUsecase(mockRepo)

	task := model.Task{ID: 1, Title: "test"}

	// ãƒ¢ãƒƒã‚¯ã®æˆ»ã‚Šå€¤ã‚’è¨­å®š
	mockRepo.On("Read", 1).Return(&task, nil)

	result, err := taskUsecase.GetTask(1)
	assert.NoError(t, err)
	assert.Equal(t, task.ID, result.ID)
	assert.Equal(t, task.Title, result.Title)
}
```

ãƒ•ã‚¡ã‚¤ãƒ«å…¨ä½“ãŒä»¥ä¸‹

- task_usecase_test.go

```go
package usecase_test

import (
	"base/model"
	"base/usecase"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

// ITaskRepositoryã®ãƒ¢ãƒƒã‚¯
type ITaskRepositoryMock struct {
	mock.Mock
}

// taskRepositoryã®Createãƒ¡ã‚½ãƒƒãƒ‰ã®ãƒ¢ãƒƒã‚¯
func (m *ITaskRepositoryMock) Create(task *model.Task) (int, error) {
	args := m.Called(task)
	return args.Int(0), args.Error(1)
}

// taskRepositoryã®Readãƒ¡ã‚½ãƒƒãƒ‰ã®ãƒ¢ãƒƒã‚¯
func (m *ITaskRepositoryMock) Read(id int) (*model.Task, error) {
	args := m.Called(id)
	return args.Get(0).(*model.Task), args.Error(1)
}

// **********************
// ã“ã“ã‹ã‚‰TaskUsecaseã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹
// **********************

// CreateTaskã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹
func TestTaskUsecase_CreateTask(t *testing.T) {
	mockRepo := new(ITaskRepositoryMock)
	taskUsecase := usecase.NewTaskUsecase(mockRepo)

	task := model.Task{Title: "test"}

	// ãƒ¢ãƒƒã‚¯ã®æˆ»ã‚Šå€¤ã‚’è¨­å®š
	mockRepo.On("Create", &task).Return(1, nil)

	id, err := taskUsecase.CreateTask(task.Title)
	assert.NoError(t, err)
	assert.Equal(t, 1, id)
}

// GetTaskã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹
func TestTaskUsecase_GetTask(t *testing.T) {
	mockRepo := new(ITaskRepositoryMock)
	taskUsecase := usecase.NewTaskUsecase(mockRepo)

	task := model.Task{ID: 1, Title: "test"}

	mockRepo.On("Read", 1).Return(&task, nil)

	result, err := taskUsecase.GetTask(1)
	assert.NoError(t, err)
	assert.Equal(t, task.ID, result.ID)
	assert.Equal(t, task.Title, result.Title)
}
```

# ã¾ã¨ã‚

ä»Šå›ã§ä¸€æ—¦ã€Go ã®åŸºæœ¬çš„ãªå­¦ç¿’ã¯ä»¥ä¸Šã«ã—ã‚ˆã†ã¨æ€ã„ã¾ã™ã€‚  
å¼•ãç¶šã Go ã®å­¦ç¿’ã‚’é€²ã‚ã¦ã„ãã¾ã™ãŒã€ãã®éƒ½åº¦æ–°ãŸãªçŸ¥è¦‹ã¯ã¾ã¨ã‚ã¦ã„ããŸã„ã¨æ€ã„ã¾ã™ã€‚
